<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: flatiron&nbsp;school | Afterhours Googling]]></title>
  <link href="http://chenghw.github.io/blog/categories/flatiron-school/atom.xml" rel="self"/>
  <link href="http://chenghw.github.io/"/>
  <updated>2015-10-28T07:12:47-04:00</updated>
  <id>http://chenghw.github.io/</id>
  <author>
    <name><![CDATA[Ho Won Cheng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Procs and Lambdas]]></title>
    <link href="http://chenghw.github.io/blog/2015/10/27/procs-and-lambdas/"/>
    <updated>2015-10-27T09:15:10-04:00</updated>
    <id>http://chenghw.github.io/blog/2015/10/27/procs-and-lambdas</id>
    <content type="html"><![CDATA[<p>I am a big believer in fundamentals and foundation. In grade school I was horrific in Spanish. Being close to failing and having to repeat the previous years Spanish class, my parents sent me to summer school. I learned the fundamentals of the language and went into the following year understanding concepts which I didn't have the tools to comprehend previously.</p>




<p>We were told a quote early on in the semester which has stuck with me. It was along the lines of, "The problem isn't with Rails, but with your Ruby." I took away to truly understand Rails was to truly understand the fundaments and the foundation that Rails was built on.</p>




<p>Before diving into Proc and Lambdas which I saw as one of those fundamentals/building blocks of the Ruby language, we must go over what a Block is first.</p>




<h2>Blocks</h2>


<p>A block is a block of code or a code block, thus the name <strong>block</strong>. A list of instructions for your code to follow. Blocks can be identified by do...end or { }. There is a saying in Ruby land that everything in Ruby is an object, however that does not apply here. A block is not an object! Which brings us to procs and lambdas.</p>




<h2>Procs</h2>


<p>Proc, stands for <strong>proc</strong>edure, is a block of code which is an object. This means procs can be passed through in method arguments, be something a method returns and have methods called upon them.</p>


<pre><code class="ruby Creating a proc">square = Proc.new{ |x| x**2 }

square = Proc.new do |x|
  x**2
end
</code></pre>

<p>Up until now we mostly been using blocks in enumerables. Procs can take the place of blocks in enumerables.</p>


<pre><code class="ruby Using a proc in an enumerable">[ 1, 2, 3, 5, 7 ].map(&amp;square)
 =&gt; [1, 4, 9, 25, 49] 
</code></pre>

<p>But lets say you don&rsquo;t want to just pass in 1 value. Using an iterator now seems to not be the right tool for the job. There is the call method.
<figure class='code'><figcaption><span>Call method</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">[</span> <span class="mi">15</span> <span class="o">].</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">square</span><span class="p">)</span>
</span><span class='line'> <span class="o">=&gt;</span> <span class="o">[</span><span class="mi">225</span><span class="o">]&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt; square.call( 15 )</span>
</span><span class='line'><span class="sr"> =&gt; 225</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Another benefit procs over blocks is that they can be returned.</p>


<pre><code class="ruby Proc as a return">class Player
  attr_accessor :coins
  def initialize
    @coins = 1000
  end
end

class Team
  attr_accessor :status
  def result
    if status
      Proc.new{ |p| p.coins += 150 }
    else
      Proc.new{ |p| p.coins -= 100 }
    end
  end
end

player1 = Player.new
player2 = Player.new
team = Team.new
team.status = true
proc = team.result

[ player1, player2 ].each(&amp;proc)
=&gt; [#&lt;Player:0x007f9682936fa0 @coins=1150&gt;, #&lt;Player:0x007f968204d1a0 @coins=1150&gt;]

player1.coins
=&gt; 1150
</code></pre>

<h2>Lambda</h2>


<p>A lambda is also a block of code which is an object. This is because a lambda is apart of the Proc class.</p>


<pre><code class="ruby Creating a lambda">woofs = lambda{ |x| "Woof!"*x }

woofs = lambda do |x|
  "Woof!"*x
end

=&gt; &lt;Proc:0x007f9683183dc0@(irb):152 (lambda)&gt; 
</code></pre>

<h2>Procs vs Lambdas</h2>


<p>1 - Procs and lambdas treat arguments differently. Procs do not check for the correct number or arguments while lambdas do.</p>


<pre><code class="ruby Argument validation">hello = Proc.new{ |name| "Hello #{name}!" }
goodbye = lambda{ |name| "Good-bye #{name}!" }
hello.call
=&gt; "Hello !"
goodbye.call
=&gt; ArgumentError: wrong number of arguments (0 for 1)
</code></pre>

<p>2 - Proc and lambdas treat returns differently. A return inside a proc will be treated as a return for the entire method which it is inside, while a return inside a lambda will only be treated as the return for inside the lambda.</p>


<pre><code class="ruby Returns">def proc_return
  proc = Proc.new do
    return "Hi from inside the proc!"
    puts "Do you see me?"
  end
  puts proc.call
  puts "Does this even show up?"
end

proc_return
 =&gt; "Hi from inside the proc!" 

def lambda_return
  lambda = lambda do
    return "Hi from inside the lambda"
    puts "Do you see me?"
  end
  puts lambda.call
  puts "Does this even show up?"
end

lambda_return
Hi from inside the lambda
Does this even show up?
 =&gt; nil 
</code></pre>

<h2> & </h2>


<pre><code class="ruby & Clarification">sym = :upcase
[ 'a', 'b', 'c' ].map( &amp;:upcase )
[ 'a', 'b', 'c' ].map{ |letter| letter.send( sym ) }
=&gt; ["A", "B", "C"] 
</code></pre>

<h2> Additional Examples </h2>


<pre><code class="ruby Examples">animal_sounds = {
  'cat' =&gt; lambda{ |x| "Meow"*x},
  'dog' =&gt; lambda{ |x| "Woof"*x},
  'pig' =&gt; lambda{ |x| "Oink"*x},
  'bird' =&gt; lambda{ |x| "Kakaw"*x}
}
animal_sounds['bird'].call(2)
=&gt; "KakawKakaw" 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Declarative Languages and Its Logical Processing Order]]></title>
    <link href="http://chenghw.github.io/blog/2015/10/12/a-declarative-languages-and-its-logical-processing-order/"/>
    <updated>2015-10-12T23:02:42-04:00</updated>
    <id>http://chenghw.github.io/blog/2015/10/12/a-declarative-languages-and-its-logical-processing-order</id>
    <content type="html"><![CDATA[<p>After two intense weeks at Flatiron School learning Ruby, we&rsquo;ve moved onto SQL, a totally different langauge. Where Ruby is an object oriented programming language used in web development, SQL is a declarative language designed to manage and query databases.</p>

<p>The transition for me was very tough going from Ruby to SQL. Ruby being a very literal language where it reacts to everything I type typically the way I would expect. Not to say I don&rsquo;t run into errors, but with tools like Pry and RSpec, debugging is managable. While this do that. For each element do this. The Ruby flow control made sense.</p>

<p>Now for SQL, I read it like any other language I encountered, from beginning to end, top to bottom. It made sense in the beginning, but started to not make sense when I got introduced to aggregate functions. Using a &lsquo;COUNT&rsquo; with a &lsquo;WHERE&rsquo; created errors which is where I learned to implement &lsquo;HAVING&rsquo;. Essentially serving the same purpose as &lsquo;WHERE&rsquo; for the query I was making, but one was necessary for aggregate functions. This sparked my curiosity and I asked myself, do I really know what is happening here?</p>

<p>My answer. No. I didn&rsquo;t really know what was happening behind the scenes and how my queries were being compiled. So I posed the question. If reading the query from beginning to end is not correct, then there must be some sort of order of opperation that SQL follows in reading syntax. But the answer I found was very unsatisfying. SQL is not like any language that I have encountered. SQL is a declarative language. Declarative language syntax is describing what the program should return rather than how this task should be accomplished. In simple terms, you tell SQL what you want and SQL will find a way to get it for you on through its own methods.</p>

<p>But there must be still rules like how I have to use &lsquo;HAVING&rsquo; instead of &lsquo;WHILE&rsquo;!! Well, there is something that we can use in fact, for &lsquo;SELECT&rsquo; statements at least. &lsquo;Logical Processing Order&rsquo; determines the order of which objects are defined and made available to other sections of the &lsquo;SELECT&rsquo; statement.</p>

<ol><strong>Logical Processing Order</strong>
<li>FROM</li>
<li>ON</li>
<li>JOIN</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>WITH CUBE or WITH ROLLUP</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>ORDER BY</li>
<li>TOP (LIMIT)</li>
</ol>


<p>Using the &lsquo;Logical Processing Order&rsquo; for &lsquo;SELECT&rsquo; statements, I was able to break down the task of creating &lsquo;SELECT&rsquo; statements into more managable steps.</p>

<p>Step #1 - Processes 1-3, what tables will I need to join for me to have all the information I need.</p>

<p>Step #2 - Processes 4-7, are there aggregate functions I need to account? If so, then I know I will need a &lsquo;GROUP BY&rsquo;, and if there is conditional logic to account for then I will need to use &lsquo;HAVING&rsquo; instead of &lsquo;WHERE&rsquo;.</p>

<p>Step #3 - Process 8, what variables do I want in my &lsquo;SELECT&rsquo; statement and do I want to rename any with &lsquo;AS&rsquo;?</p>

<p>Step #4 - Processes 9-11, am I looking for the query to output in a specific order or by a limit?</p>

<p>Knowing the control flow and asking the right questions.</p>
]]></content>
  </entry>
  
</feed>
